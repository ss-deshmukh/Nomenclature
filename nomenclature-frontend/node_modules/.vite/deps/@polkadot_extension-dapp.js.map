{
  "version": 3,
  "sources": ["../../@polkadot/extension-dapp/util.js", "../../@polkadot/extension-dapp/packageInfo.js", "../../@polkadot/extension-dapp/wrapBytes.js", "../../@polkadot/extension-dapp/bundle.js"],
  "sourcesContent": ["export function documentReadyPromise(creator) {\n    return new Promise((resolve) => {\n        if (document.readyState === 'complete') {\n            resolve(creator());\n        }\n        else {\n            window.addEventListener('load', () => resolve(creator()));\n        }\n    });\n}\n", "export const packageInfo = { name: '@polkadot/extension-dapp', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '0.46.9' };\n", "import { U8A_WRAP_ETHEREUM, U8A_WRAP_POSTFIX, U8A_WRAP_PREFIX, u8aIsWrapped, u8aUnwrapBytes, u8aWrapBytes } from '@polkadot/util';\nexport const ETHEREUM = U8A_WRAP_ETHEREUM;\nexport const POSTFIX = U8A_WRAP_POSTFIX;\nexport const PREFIX = U8A_WRAP_PREFIX;\nexport const isWrapped = u8aIsWrapped;\nexport const unwrapBytes = u8aUnwrapBytes;\nexport const wrapBytes = u8aWrapBytes;\n", "import { isPromise, objectSpread, u8aEq } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\nimport { documentReadyPromise } from './util.js';\nexport { packageInfo } from './packageInfo.js';\nexport { unwrapBytes, wrapBytes } from './wrapBytes.js';\nconst win = window;\nwin.injectedWeb3 = win.injectedWeb3 || {};\nlet isWeb3Injected = web3IsInjected();\nlet web3EnablePromise = null;\nexport { isWeb3Injected, web3EnablePromise };\n/** @internal true when anything has been injected and is available */\nfunction web3IsInjected() {\n    return Object\n        .values(win.injectedWeb3)\n        .filter(({ connect, enable }) => !!(connect || enable))\n        .length !== 0;\n}\n/** @internal throw a consistent error when not extensions have not been enabled */\nfunction throwError(method) {\n    throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n}\n/** @internal map from Array<InjectedAccount> to Array<InjectedAccountWithMeta> */\nfunction mapAccounts(source, list, ss58Format) {\n    return list.map(({ address, genesisHash, name, type }) => ({\n        address: address.length === 42\n            ? address\n            : encodeAddress(decodeAddress(address), ss58Format),\n        meta: { genesisHash, name, source },\n        type\n    }));\n}\n/** @internal filter accounts based on genesisHash and type of account */\nfunction filterAccounts(list, genesisHash, type) {\n    return list.filter((a) => (!a.type || !type || type.includes(a.type)) &&\n        (!a.genesisHash || !genesisHash || a.genesisHash === genesisHash));\n}\n/** @internal retrieves all the extensions available on the window */\nfunction getWindowExtensions(originName) {\n    return Promise\n        .all(Object\n        .entries(win.injectedWeb3)\n        .map(([nameOrHash, { connect, enable, version }]) => Promise\n        .resolve()\n        .then(() => connect\n        // new style, returning all info\n        ? connect(originName)\n        : enable\n            // previous interface, leakages on name/version\n            ? enable(originName).then((e) => objectSpread({ name: nameOrHash, version: version || 'unknown' }, e))\n            : Promise.reject(new Error('No connect(..) or enable(...) hook found')))\n        .catch(({ message }) => {\n        console.error(`Error initializing ${nameOrHash}: ${message}`);\n    })))\n        .then((exts) => exts.filter((e) => !!e));\n}\n/** @internal Ensure the enable promise is resolved and filter by extensions */\nasync function filterEnable(caller, extensions) {\n    if (!web3EnablePromise) {\n        return throwError(caller);\n    }\n    const sources = await web3EnablePromise;\n    return sources.filter(({ name }) => !extensions ||\n        extensions.includes(name));\n}\n/**\n * @summary Enables all the providers found on the injected window interface\n * @description\n * Enables all injected extensions that has been found on the page. This\n * should be called before making use of any other web3* functions.\n */\nexport function web3Enable(originName, compatInits = []) {\n    if (!originName) {\n        throw new Error('You must pass a name for your app to the web3Enable function');\n    }\n    const initCompat = compatInits.length\n        ? Promise.all(compatInits.map((c) => c().catch(() => false)))\n        : Promise.resolve([true]);\n    web3EnablePromise = documentReadyPromise(() => initCompat.then(() => getWindowExtensions(originName)\n        .then((values) => values.map((e) => {\n        // if we don't have an accounts subscriber, add a single-shot version\n        if (!e.accounts.subscribe) {\n            e.accounts.subscribe = (cb) => {\n                e.accounts\n                    .get()\n                    .then(cb)\n                    .catch(console.error);\n                return () => {\n                    // no ubsubscribe needed, this is a single-shot\n                };\n            };\n        }\n        return e;\n    }))\n        .catch(() => [])\n        .then((values) => {\n        const names = values.map(({ name, version }) => `${name}/${version}`);\n        isWeb3Injected = web3IsInjected();\n        console.info(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n        return values;\n    })));\n    return web3EnablePromise;\n}\n/**\n * @summary Retrieves all the accounts across all providers\n * @description\n * This returns the full list of account available (accross all extensions) to\n * the page. Filtereing options are available of a per-extension, per type and\n * per-genesisHash basis. Optionally the accounts can be encoded with the provided\n * ss58Format\n */\nexport async function web3Accounts({ accountType, extensions, genesisHash, ss58Format } = {}) {\n    const accounts = [];\n    const sources = await filterEnable('web3Accounts', extensions);\n    const retrieved = await Promise.all(sources.map(async ({ accounts, name: source }) => {\n        try {\n            const list = await accounts.get();\n            return mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format);\n        }\n        catch {\n            // cannot handle this one\n            return [];\n        }\n    }));\n    retrieved.forEach((result) => {\n        accounts.push(...result);\n    });\n    console.info(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}`);\n    return accounts;\n}\n/**\n * @summary Subscribes to all the accounts across all providers\n * @description\n * This is the subscription version of the web3Accounts interface with\n * updates as to when new accounts do become available. The list of filtering\n * options are the same as for the web3Accounts interface.\n */\nexport async function web3AccountsSubscribe(cb, { accountType, extensions, genesisHash, ss58Format } = {}) {\n    const sources = await filterEnable('web3AccountsSubscribe', extensions);\n    const accounts = {};\n    const triggerUpdate = () => cb(Object\n        .entries(accounts)\n        .reduce((result, [source, list]) => {\n        result.push(...mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format));\n        return result;\n    }, []));\n    const unsubs = sources.map(({ accounts: { subscribe }, name: source }) => subscribe((result) => {\n        accounts[source] = result;\n        try {\n            const result = triggerUpdate();\n            if (result && isPromise(result)) {\n                result.catch(console.error);\n            }\n        }\n        catch (error) {\n            console.error(error);\n        }\n    }));\n    return () => {\n        unsubs.forEach((unsub) => {\n            unsub();\n        });\n    };\n}\n/**\n * @summary Finds a specific provider based on the name\n * @description\n * This retrieves a specific source (extension) based on the name. In most\n * cases it should not be needed to call it directly (e.g. it is used internally\n * by calls such as web3FromAddress) but would allow operation on a specific\n * known extension.\n */\nexport async function web3FromSource(source) {\n    if (!web3EnablePromise) {\n        return throwError('web3FromSource');\n    }\n    const sources = await web3EnablePromise;\n    const found = source && sources.find(({ name }) => name === source);\n    if (!found) {\n        throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n    }\n    return found;\n}\n/**\n * @summary Find a specific provider that provides a specific address\n * @description\n * Based on an address, return the provider that has makes this address\n * available to the page.\n */\nexport async function web3FromAddress(address) {\n    if (!web3EnablePromise) {\n        return throwError('web3FromAddress');\n    }\n    const accounts = await web3Accounts();\n    let found;\n    if (address) {\n        const accountU8a = decodeAddress(address);\n        found = accounts.find((account) => u8aEq(decodeAddress(account.address), accountU8a));\n    }\n    if (!found) {\n        throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n    }\n    return web3FromSource(found.meta.source);\n}\n/**\n * @summary List all providers exposed by one source\n * @description\n * For extensions that supply RPC providers, this call would return the list\n * of RPC providers that any extension may supply.\n */\nexport async function web3ListRpcProviders(source) {\n    const { provider } = await web3FromSource(source);\n    if (!provider) {\n        console.warn(`Extension ${source} does not expose any provider`);\n        return null;\n    }\n    return provider.listProviders();\n}\n/**\n * @summary Start an RPC provider provider by a specific source\n * @description\n * For extensions that supply RPC providers, this call would return an\n * enabled provider (initialized with the specific key) from the\n * specified extension source.\n */\nexport async function web3UseRpcProvider(source, key) {\n    const { provider } = await web3FromSource(source);\n    if (!provider) {\n        throw new Error(`Extension ${source} does not expose any provider`);\n    }\n    const meta = await provider.startProvider(key);\n    return { meta, provider };\n}\n"],
  "mappings": "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",
  "names": ["accounts", "result"]
}
